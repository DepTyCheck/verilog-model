stage: synthesis
short_desc: (implicit) uwire <name> must have a single driver, found <num>
tool: iverilog
id: uwire_must_have_single_driver
title: Uwire must have single driver
regex: >
  (\(implicit\) |)uwire "\w+" must have a single driver, found \(\d+\)
issue_link: https://github.com/steveicarus/iverilog/issues/1267
issue_novelty: new
examples:
  - implicit_uwire_must_have_single_driver:
      first_found: 03.04.2025
      minified_example: |
        module a(output bit a1);
          or zlsdkl(a1, a1, w1);
        endmodule: a

        module b();

          a a_inst(.a1(b1));

          assign b1 = 'b0;
          assign b1 = 'b0;

        endmodule: b
      minified_error: >
        vvp.tgt error: (implicit) uwire "b1" must have a single driver, found (3).
      full_error: >
        error: (implicit) uwire "qpqlbpygsh" must have a single driver, found (3).
      full_example: |
        module bdaodpsf
          (output bit clgyzohvz, output logic hzo [0:4][0:2]);

          or zlsdkl(clgyzohvz, clgyzohvz, atbnehnw);

          // Top inputs -> top outputs assigns

          // Assigns
          assign atbnehnw = 'b0;
          assign hzo = '{'{'b0,'bx,'bx},'{'b1,'b1,'b0},'{'b0,'bz,'bx},'{'b1,'bz,'bx},'{'bz,'bz,'bz}};
        endmodule: bdaodpsf

        module zorm
          (output integer ufqubxhuxl, input wire nr [3:4][3:2], input logic [4:1] r);

          logic s [0:4][0:2];

          or xkqdjlbiqd(eozw, rxadmiqii, gy);
          bdaodpsf lmjvjkhxr(.clgyzohvz(rxadmiqii), .hzo(s));

          // Top inputs -> top outputs assigns

          // Assigns
          assign gy = 'b0;
        endmodule: zorm

        module ly
          ( output bit [1:1] usgt [4:0]
          , output logic [0:2] ik
          , output int ejuzdxugxb
          , input logic [3:1][4:3][4:1] ywlchwplkp
          , input int z
          , input wire dpseqfo
          , input logic [0:4] fravs
          );

          logic zaz [0:4][0:2];
          logic rmmead [0:4][0:2];

          bdaodpsf ht(.clgyzohvz(qpqlbpygsh), .hzo(zaz));
          bdaodpsf cihddeut(.clgyzohvz(mjv), .hzo(rmmead));

          // Top inputs -> top outputs assigns

          // Assigns
          assign ik = 'bzz0;
          assign ejuzdxugxb = 'b1;
          assign usgt = '{'b0,'b0,'b1,'b1,'b1};
          assign dpseqfo = 'b1;
          assign qpqlbpygsh = 'b0;
          assign qpqlbpygsh = 'b0;
        endmodule: ly

        module ofdvh
          ( output logic [3:1] yw
          , output logic [0:0][2:0][4:0] atf
          , output int cechaeibm [0:1]
          , input bit [3:4] wj
          , input bit wfyyslk [3:1][0:3]
          , input logic [2:0] em [4:3]
          , input bit nvhxl [0:1]
          );

          logic iwizhrmspm [0:4][0:2];

          bdaodpsf k(.clgyzohvz(yw), .hzo(iwizhrmspm));

          // Top inputs -> top outputs assigns

          // Assigns
          assign cechaeibm = '{'b0,'b1};
          assign atf = 'b110z1011z01x110;
        endmodule: ofdvh
  - explicit_uwire_must_have_single_driver:
    first_found: 11.04.2025
    minified_error: >
      vvp.tgt error: uwire "logic_b" must have a single driver, found (2).
    minified_example: |
      module a(output wire wire_a);

      assign wire_a = 'b0;
      assign wire_a = 'b0;

      endmodule: a

      module b(output logic logic_b);

      a ixtiaryxx(.wire_a(logic_b));
      and quhh(w1, logic_b, w2);

      endmodule: b
    full_error: >
      vvp.tgt error: uwire "qwxtubwydz" must have a single driver, found (3).
    full_example: |
      // Seed: 11839031070210974510,14186438219062418103

      module vv
        ( output logic [0:1] mwxt [3:1]
        , output bit [1:2][2:2] cr
        , output real nn
        , output uwire bfzltt [3:4]
        , input logic [0:0][2:1] kymxa
        , input logic jzpnoniz
        , input bit [0:3] ne
        );


        nand lapedc(tfmgnotlfr, kymxa, ne);
        not rj(ymamkybxj, ymamkybxj);
        not nzppo(zhbaa, ne);
        or yjef(ody, tfmgnotlfr, ymamkybxj);

        // Top inputs -> top outputs assigns
        assign cr = ne;
        assign nn = kymxa;

        // Assigns
        assign mwxt = '{'b01,'bx1,'bz0};
      endmodule: vv

      module b
        (output wire qghiphzqmc, output bit [0:3] om, output bit [4:3][1:3][1:0] zp, output logic [0:0] mkdyjtbf, input bit [4:1] kam);

        logic [0:1] soaa [3:1];
        uwire aefjsxosif [3:4];

        vv iuyu(.mwxt(soaa), .cr(om), .nn(zp), .bfzltt(aefjsxosif), .kymxa(zp), .jzpnoniz(zp), .ne(zp));
        nand iqooxdk(mwwzb, zp, om);
        nand ggxst(dhojvrjdu, xwqla, wzqesd);

        // Top inputs -> top outputs assigns

        // Assigns
        assign xwqla = 'bz;
        assign qghiphzqmc = 'b0;
        assign qghiphzqmc = 'b0;
        assign qghiphzqmc = 'b0;
        assign mkdyjtbf = 'bz;
      endmodule: b

      module xsordikq
        (output wire oryz, output logic [3:0] rslgu, input uwire gotm, input logic [3:1] jcrix, input logic [3:4] ynpvxr);


        nand ovkoksy(v, ze, jcrix);

        // Top inputs -> top outputs assigns

        // Assigns
        assign ze = 'b1;
        assign ze = 'b1;
        assign ze = 'bz;
        assign oryz = 'b0;
        assign rslgu = 'b1xxx;
        assign v = 'b1;
      endmodule: xsordikq

      module ahszrxtym
        (output uwire l [1:2][3:3], output logic [2:2] qwxtubwydz, output bit [2:4] blce [0:2]);


        b lmemc(.qghiphzqmc(e), .om(qpfnbi), .zp(ww), .mkdyjtbf(vrnnhzca), .kam(nwkoeen));
        b ixtiaryxx(.qghiphzqmc(qwxtubwydz), .om(t), .zp(pbf), .mkdyjtbf(pvf), .kam(e));
        and quhh(lnsyrbg, qwxtubwydz, mtbsnvkts);

        // Top inputs -> top outputs assigns

        // Assigns
        assign mtbsnvkts = 'bz;
        assign mtbsnvkts = 'bz;
        assign mtbsnvkts = 'b1;
        assign nwkoeen = 'b0001;
        assign vrnnhzca = 'b0;
        assign qpfnbi = 'b0010;
      endmodule: ahszrxtym



      // Seed after: 7415663828183734803,14186438219062418103
  - implicit_uwire_must_have_single_driver_modern:
      first_found: 05.08.2025
      minified_error: |
        top.sv:5: vvp.tgt error: (implicit) uwire "b1" must have a single driver, found (2).
        error: Code generation had 1 error(s).
      minified_example: |
        module a(input uwire logic a1);  
        endmodule: a

        module b();
          wire logic b1;

          a b_inst(.a1(b1));
          not not_inst(b1, b1);

          assign b1 = 'b0;
        endmodule: b
      full_error: >
        vvp.tgt error: (implicit) uwire "dkaj" must have a single driver, found (2).
        error: Code generation had 1 error(s).
      full_example: |
        module mtutgxeq
          (output logic [0:4][1:1][4:1][4:1] ugwcgvpnw, input uwire logic voipkih, input reg [2:4][4:0] zkrzn);
          
          // Top inputs -> top outputs assigns
          
          // Single-driven assigns
          assign ugwcgvpnw = 'bz;
          
          // Multi-driven assigns
        endmodule: mtutgxeq

        module vcrsojld
          (input uwire logic [0:2][0:1][2:1] xjrvsiwxji [1:3][1:3][0:1]);
          
          
          xor ximaoco(znxfm, znxfm, ua);
          
          not eerh(ywrjtro, pxbquxytk);
          
          mtutgxeq ao(.ugwcgvpnw(ua), .voipkih(mkoxifge), .zkrzn(iwcg));
          // warning: implicit conversion of port connection truncates from 80 to 1 bits
          //   logic [0:4][1:1][4:1][4:1] ugwcgvpnw -> wire logic ua
          //
          // warning: implicit conversion of port connection expands from 1 to 15 bits
          //   wire logic iwcg -> reg [2:4][4:0] zkrzn
          
          xor hyt(n, vmiw, znxfm);
          
          
          // Top inputs -> top outputs assigns
          
          // Single-driven assigns
          assign vmiw = 'bx;
          assign iwcg = 'b1;
          assign mkoxifge = 'b1;
          
          // Multi-driven assigns
          assign n = 'b0;
          assign znxfm = 'bz;
          assign n = 'bz;
          assign ua = 'b0;
        endmodule: vcrsojld

        module obfevrtsu
          (output bit [4:4] wj [0:0][1:0], output bit jryyapx);
          
          
          not nectitol(bp, tnyekiqhno);
          
          xor uec(tzlxr, dkaj, w);
          
          mtutgxeq tltiy(.ugwcgvpnw(tnyekiqhno), .voipkih(dkaj), .zkrzn(xqkeslrdh));
          // warning: implicit conversion of port connection truncates from 80 to 1 bits
          //   logic [0:4][1:1][4:1][4:1] ugwcgvpnw -> wire logic tnyekiqhno
          //
          // warning: implicit conversion of port connection expands from 1 to 15 bits
          //   wire logic xqkeslrdh -> reg [2:4][4:0] zkrzn
          
          not tuiir(dkaj, dkaj);
          
          
          // Top inputs -> top outputs assigns
          
          // Single-driven assigns
          
          // Multi-driven assigns
          assign dkaj = 'bz;
          assign dkaj = 'bz;
          assign dkaj = 'b0;
        endmodule: obfevrtsu

        module pa
          (output real uamkgq [3:2]);
          
          uwire logic [0:2][0:1][2:1] uxxquioey [1:3][1:3][0:1];
          
          vcrsojld r(.xjrvsiwxji(uxxquioey));
          
          
          // Top inputs -> top outputs assigns
          
          // Single-driven assigns
          assign uxxquioey = '{'{'{'bx,'b1},'{'bx,'b1},'{'bx,'bz}},'{'{'b0,'b0},'{'b1,'b1},'{'b1,'b1}},'{'{'b0,'bz},'{'bx,'bx},'{'b1,'b1}}};
          assign uamkgq = '{'b0,'b1};
          
          // Multi-driven assigns
        endmodule: pa
