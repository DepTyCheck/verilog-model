import fs from 'fs';
import path from 'path';
import { parse } from 'yaml';
import { fileURLToPath } from 'url';

// Function to recursively find all YAML files
function findYamlFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      findYamlFiles(filePath, fileList);
    } else if (file.endsWith('.yaml') || file.endsWith('.yml')) {
      fileList.push(filePath);
    }
  }
  
  return fileList;
}

// Function to parse a YAML file and convert it to FoundError format
function parseYamlFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const doc = parse(content);
    
    const { stage, tool, id, short_desc, title, examples, issue_novelty, issue_link, maintainers_response } = doc;
    
    const parsedExamples = [];
    if (Array.isArray(examples)) {
      for (const example of examples) {
        const entries = Object.entries(example);
        const [exampleId, dataRaw] = entries[0];
        const data = (dataRaw && typeof dataRaw === 'object') ? dataRaw : {};
        
        parsedExamples.push({
          id: exampleId,
          first_found: data.first_found ? parseDate(data.first_found) : null,
          minified_example: data.minified_example ?? null,
          minified_error: data.minified_error ?? null,
          full_error: data.full_error ?? null,
          full_example: data.full_example ?? null
        });
      }
    }
    
    return {
      stage: stage,
      tool,
      id,
      title,
      short_desc: short_desc || null,
      examples: parsedExamples,
      issue_novelty: issue_novelty || null,
      issue_link: issue_link || null,
      maintainers_response: maintainers_response || null,
    };
  } catch (error) {
    console.error(`Error parsing ${filePath}:`, error.message);
    return null;
  }
}

// Helper function to parse date from DD.MM.YYYY format
function parseDate(dateStr) {
  if (!dateStr) return null;
  const match = /^(\d{2})\.(\d{2})\.(\d{4})$/.exec(dateStr);
  if (match) {
    const [, day, month, year] = match;
    // Convert to YYYY-MM-DD for Date constructor
    return new Date(`${year}-${month}-${day}`);
  }
  // Fallback to native Date parsing
  return new Date(dateStr);
}

// Function to generate TypeScript content
function generateTypeScriptContent(errors) {
  const validErrors = errors.filter(error => error !== null);
  
  return `// This file is auto-generated by scripts/gen_errors_data.js
// Do not edit manually

import type { FoundError } from '$lib/core';

export const allFoundErrors: FoundError[] = ${JSON.stringify(validErrors, null, 2)};
`;
}

function main() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const foundErrorsDir = path.join(__dirname, '..', 'found_errors');
  const outputFile = path.join(__dirname, '..', 'src', 'lib', 'generated', 'errors_data.ts');
  
  console.log('Scanning for YAML files in found_errors directory...');
  
  if (!fs.existsSync(foundErrorsDir)) {
    console.error('found_errors directory does not exist!');
    process.exit(1);
  }
  
  const yamlFiles = findYamlFiles(foundErrorsDir);
  console.log(`Found ${yamlFiles.length} YAML files`);
  
  const errors = [];
  for (const filePath of yamlFiles) {
    console.log(`Parsing: ${filePath}`);
    const error = parseYamlFile(filePath);
    if (error) {
      errors.push(error);
    }
  }
  
  console.log(`Successfully parsed ${errors.length} error files`);
  
  const tsContent = generateTypeScriptContent(errors);
  
  // Ensure the output directory exists
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(outputFile, tsContent);
  console.log(`Generated TypeScript file: ${outputFile}`);
  console.log('Script completed successfully!');
}

main();